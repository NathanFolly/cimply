#include "simmeranalysis.h"
#include <stdio.h>
#include <string.h>

static void * readfromsim05file(void * _self);

static void * SimmerAnalysis_ctor(void * _self, va_list * app){
  struct SimmerAnalysis * self = _self;
  /* intializing the variables */
  self->PK = NULL;
  /* reading the sim05 file */
  readfromsim05file(self);
  /* allocating the correct size of the variable vectors */
  self->PK = (double *) calloc(self->MMS, sizeof(double));
#include "interface.h"
#include "femanalysis.h"
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>

static void * Interface_getPhantomFractions(void * _self, float ** PhantomFractions);
static void * Interface_prepare(void * _self);
static void * Interface_assign(void * _self, void * _b);

static void * Interface_ctor(void * _self, va_list * app){
  struct Interface * self = _self;

  self->phantommesh = new(PhantomMesh);

  self->getPhantomFractions = Interface_getPhantomFractions;
  self->prepare = Interface_prepare;
  self->assign = Interface_assign;
  
  
  return self;
}

static void * Interface_dtor(void * _self){
  struct Interface * self = _self;
  if(self->SIMMsh){
    delete(self->SIMMsh);
  }
  return self;
}

static void * Interface_update(void * _self){
  struct Interface * self = _self;
  if(self->FEM){
    assert(self->FEM);
    update(self->FEM);
  }
  /* if(!self->SIMMsh){ */
  /*   fprintf(stderr,"ERROR :: Interface has no SIMMER Mesh assigned to it yet\n"); */
  /*   return 0; */
  /* } */
  /* update(self->SIMMsh); */
  update(self->phantommesh);
  return 0;
}

static const struct Class _Interface = {sizeof(struct Interface), Interface_ctor, Interface_dtor, Interface_update};

const void * Interface = &_Interface;
/* ------------------- End of Class definition ------------- */








/* -------------------- Class specific functions: ---------- */

static void * Interface_assign(void * _self,void * _b){
  struct Interface * self = _self;
  const struct Class ** cp = _self;
  const struct Class ** b = _b;  /* class pointerpointer (first element in every class) */
  assert(*cp = Interface);
  if(*b == FEMAnalysis){         /* check if second argument has correct class */
    struct FEMAnalysis * FEM = _b;
    self->FEM = FEM;
  }
  else if(*b == SimmerAnalysis){
    struct SimmerAnalysis * simmeranalysis =_b;
    self->simmeranalysis = simmeranalysis;
    /* TODO: this does not confirm to the concept of information hiding. better create a simmermesh object that both other objects share or functions to assign meshes to objects */
    assert(self->phantommesh);
    self->phantommesh->DRINP = self->simmeranalysis->DRINP;
    self->phantommesh->DZINP = self->simmeranalysis->DZINP;
    self->phantommesh->MMS = self->simmeranalysis->MMS;
    self->phantommesh->JB = self->simmeranalysis->JB;
    self->phantommesh->IB = self->simmeranalysis->IB;
    self->phantommesh->phantomcell = (void **) calloc(self->phantommesh->MMS,sizeof(void **));
  }
  else{
    fprintf(stderr,"Second input argument: unsupported format. Expected FEMAnalysis or simmeranalysis. \n");
  }
  return 0;
}


/* this is ugly. we should be able to call getPhantomFractions on interfaces, SimmerMeshes and PhantomCells. like this it is only possible for interfaces*/
static void * Interface_getPhantomFractions(void * _self, float ** PhantomFractions){
 const struct Interface * self = _self;
 if(!self->phantommesh){
   fprintf(stderr,"ERROR :: Interface has no SIMMER Mesh assigned to it yet\n");
   return 0;
 }
 struct PhantomMesh * phantommesh = self->phantommesh;
  assert(self->class==Interface);
  getPhantomFractions(phantommesh,PhantomFractions);
  return 0;
}

void * pull(void * _self) {
  printf("pulling \n");
  return 0;
}

static void * Interface_prepare(void * _self) {
  struct Interface * self = _self;
  assert(self->class==Interface);
  printf("preparing the interface... \n");
  self->SIMMsh=new(SIMMsh);  /* creating a ne simmermesh */
  prepare(self->SIMMsh);     /* preparing the new simmermesh */
  return 0;
}

  return self;
}

static void * SimmerAnalysis_dtor(void * _self){
  struct SimmerAnalysis * self = _self;
  if(self->DRINP){
    free(self->DRINP);
  }
  if(self->DZINP){
    free(self->DZINP);
  }
  if(self->PK){
    free(self->PK);
  }
  return self;
}

static void * SimmerAnalysis_update(void * _self){
  struct SimmerAnalysis * self = _self;
  /* TODO: what shoudl this do? */
  return 0;
}

static const struct Class _SimmerAnalysis = {sizeof(struct SimmerAnalysis),SimmerAnalysis_ctor,SimmerAnalysis_dtor, SimmerAnalysis_update};

const void * SimmerAnalysis = &_SimmerAnalysis;










/*-------------- reader for the sim05 file ----------- */


static void * readfromsim05file(void * _self){

  struct SimmerAnalysis * self = _self;

  
  /* basically copied from sim05reader */
  /* TODO: make this more robust. Likely to break if format of input varies. */
  /* TODO: introduce simmerdata class. put TWFIN and PK etc there. simmerdata should have a simmermesh class object as attribute */
  FILE *sim05;
  char rstrng[20], valstrng[20];  /* rstrng is an actual string used to
                                   * identify which variables is defined in
                                   * the sim05 file
                                   valstrng is actually a value. sometimes it
                                   has the fortran style double notation
                                   (2.50000D-2) which c cannot read so we
                                   have to manipulate. Sometimes there is a multiplier*/
  int rint;         /* The integer we read in from the file */
  PetscReal rreal;  /* The float we read in from the file */
  int startat, NSSize=1;      /* start point for the grid size definition,
                                * number of cells with the same size */
  int IBFilled=0, JBFilled=0;  /* number of cells that we have registered the
                            * heigths for */
  double hcell;     /* cell height */
  int xmshread = 0;  /* 0= Tag &XMSH not encountered yet in sim05 file
                        1= in XMSH region; next job: read number of cells in
                        each dir
                        2= in XMSH region; next job: read cell sizes
                        3= completed read
                        4= encountered &END after &XMSH before completing
                        data read*/
  int xtmeread = 0;  /* Same principle as for xmshread. Just for the time
                      * context */
  PetscInt IB;
  PetscInt JB;
  PetscInt IBP2;
  PetscInt JBP2;
  PetscInt MMS;
  PetscReal * DRINP;
  PetscReal * DZINP;
  PetscReal TWFIN;
  
  PetscErrorCode ierr;
  sim05 = fopen("sim05","r");
  if (sim05){
    while(xmshread==0)
    {
      fscanf(sim05,"%s",rstrng);
      if(strcmp(rstrng,"&XMSH")==0){
        xmshread=1;
      }
    }
    while(xmshread==1)
    {
      fscanf(sim05,"%2s %*[=] %d %*[,]",rstrng, &rint);
      if(strcmp(rstrng,"IB")==0) self->IB=rint;
      if(strcmp(rstrng,"JB")==0) self->JB=rint;
      if(self->IB*self->JB!=0) xmshread=2;  /* once both variables
                                                       * are assigned values:continue */
    }
    self->DRINP = (double *) calloc(self->IB, sizeof(double));
    self->DZINP = (double *) calloc(self->JB, sizeof(double));
    /* strcp(frmt, "%5c %u") */
    while(xmshread==2)
    {
      int i = 0;
      fscanf(sim05,"%5s %*[(] %d %*[)] %*[=] %19s",rstrng,&startat,valstrng);
      NSSize=1;
      while (valstrng[i]!='\0') 
      {
        if (valstrng[i]=='D') valstrng[i]='E';  /* replacing D with E so that C can read the
                                                 * float  */
        if (valstrng[i]=='*') NSSize=0;  /* we have more than one
                                          * cell with the same height */
        i++;
      }
      if (NSSize==0) sscanf(valstrng, "%d %*[*] %lG",&NSSize, &hcell);
      else sscanf(valstrng, "%lG", &hcell);
      for (i=startat-1;i<startat+NSSize-1;i++)
      {
        if(strcmp(rstrng,"DRINP")==0)
        {
          self->DRINP[i]=hcell;
          IBFilled++;
        }
        if(strcmp(rstrng,"DZINP")==0)
        {
          self->DZINP[i]=hcell;
          JBFilled++;
        }
      }
      if ((IBFilled==self->IB)&&(JBFilled==self->JB)) xmshread=3;
      if (strcmp(rstrng,"&END")==0) {
        xmshread=4;

      }
    }
      
    /* while(xmshread==1) */
    /* { */
    if(xmshread==4) {
      fprintf(stderr, "ERROR reading the meshdata from the sim05 file.\n");
      exit(0);
    }
    
 while(xtmeread==0)
    {
      fscanf(sim05,"%s",rstrng);
      if(strcmp(rstrng,"&XTME")==0){
        xtmeread=1;
      }
    }
    while(xtmeread==1)
    {
      /* fscanf(sim05,"%5s %*[=] %f %*s %i %*[,]",rstrng, &rreal, &power); */
      int i =0;
      fscanf(sim05,"%5s %*[=] %19s",rstrng,valstrng);
      NSSize=1;
      while (valstrng[i]!='\0') 
      {
        int EOFortDoub;
        if (valstrng[i]=='D') valstrng[i]='E';  /* replacing D with E so that C can read the
                                                 * float  */
        if (valstrng[i]==',') EOFortDoub=1;  /* we have more than one
                                              * cell with the same height */
        if (EOFortDoub==1) valstrng[i] = ' ';
        i++;
      }
      sscanf(valstrng, "%lG", &rreal);
      
      if(strcmp(rstrng,"TWFIN")==0) {
        self->TWFIN=rreal;
      }
      if(self->TWFIN!=0) xtmeread=2;
      if (strcmp(rstrng,"&END")==0) {
        xtmeread=4;
      }
    }

    /* while(xmshread==1) */
    /* { */
    if(xtmeread==4) {
      fprintf(stderr, "ERROR reading the time data from the sim05 file.\n");
      exit(0);
    }
    fclose(sim05);
  }
  self->JBP2 = self->JB+2;
  self->IBP2 = self->IB+2;
  self->MMS = self->JBP2*self->IBP2;
  free(self->PK);

  return 0;
 
}
